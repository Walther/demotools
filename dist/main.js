!function(e){function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}var t={};n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(n){return e[n]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=0)}([function(e,n,t){function r(){l=(new Date).getTime()-s,(i=.001*l)<=u&&window.requestAnimationFrame(r),c.clear(c.COLOR_BUFFER_BIT|c.DEPTH_BUFFER_BIT),c.uniform1f(c.getUniformLocation(a,"time"),i),c.viewportWidth=o.width,c.viewportHeight=o.height,c.viewport(0,0,c.viewportWidth,c.viewportHeight),c.uniform2f(c.getUniformLocation(a,"resolution"),c.viewportWidth,c.viewportHeight);var e;e=c.createBuffer(),c.bindBuffer(c.ARRAY_BUFFER,e),c.bufferData(c.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),c.STATIC_DRAW),e.itemSize=2,e.numItems=6,c.vertexAttribPointer(a.vertexPositionAttribute,e.itemSize,c.FLOAT,!1,0,0),c.drawArrays(c.TRIANGLES,0,6)}var o=document.createElement("canvas");document.body.appendChild(o);var i,a,c=o.getContext("experimental-webgl"),s=(new Date).getTime(),l=0,u=10;window.AudioContext=window.AudioContext||window.webkitAudioContext;var f=new AudioContext;(function(e,n,t){for(var r=l,o=n.length,i=0;r<=u&&!0===t;)for(var a=0;a<o;a++){var c;i=.5*n[a].l,(c=e(r,n[a].f,n[a].v)).start(r),c.stop(r+i),r+=i}})(function(e,n,t){var r=f.createOscillator();r.type="sine",r.frequency.exponentialRampToValueAtTime(50,e+1),r.frequency.setValueAtTime(n,e);var o=f.createGain();return o.gain.setValueAtTime(t,e),o.gain.exponentialRampToValueAtTime(.001,e+.5),r.connect(o),o.connect(f.destination),r},[{f:"100.0",l:1,v:1}],!0),function(){function e(){o.width=window.innerWidth,o.height=window.innerHeight,function(){function e(e,n,t){var r;if("fragment"==t)r=e.createShader(e.FRAGMENT_SHADER);else{if("vertex"!=t)return null;r=e.createShader(e.VERTEX_SHADER)}return e.shaderSource(r,n),e.compileShader(r),r}var n=t(1),o=t(2),i=e(c,o,"fragment"),s=e(c,n,"vertex");a=c.createProgram(),c.attachShader(a,s),c.attachShader(a,i),c.linkProgram(a),c.getProgramParameter(a,c.LINK_STATUS)||alert("Could not initialise shaders"),c.useProgram(a),a.vertexPositionAttribute=c.getAttribLocation(a,"aVertexPosition"),c.enableVertexAttribArray(a.vertexPositionAttribute),r()}()}window.addEventListener("resize",e,!1),e()}()},function(e,n){e.exports="attribute vec3 aVertexPosition;\nvoid main(void) {\n  gl_Position = vec4(aVertexPosition, 1.0);\n}\n"},function(e,n){e.exports="precision highp float;\nuniform float time;\nuniform vec2 resolution;\n\nconst int MAX_ITER = 128;\nconst float MAX_DIST = 32.0;\nconst float EPSILON = 0.001;\nconst int MAX_RECURSE = 1; // Reflections\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec3 v) {\n  return max(max(v.x, v.y), v.z);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n  vec3 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5, size) - size*0.5;\n  return c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  if (p >= 0.0) {\n    p = mod(p + halfsize, size) - halfsize;\n  }\n  return c;\n}\n\n// Primitives\n\nfloat fSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n// Rotations\n\nmat3 rotateX(float v){return mat3(1,0,0,0,cos(v),-sin(v),0,sin(v),cos(v));}\nmat3 rotateY(float v){return mat3(cos(v),0,sin(v),0,1,0,-sin(v),0,cos(v));}\nmat3 rotateZ(float v){return mat3(cos(v),-sin(v),0,sin(v),cos(v),0,0,0,1);}\n\n// END HELPERS\n\n// Distance field: insert objects here\nfloat distfunc(vec3 pos)\n{\n  float field;\n\n  // Save space for cube\n  vec3 cubeSpace = pos;\n  // rotate cube space\n  cubeSpace *= rotateX(time);\n  cubeSpace *= rotateZ(time);\n  // Insert cube\n  float cube = fBox(cubeSpace, vec3(0.2));\n\n  // Dodge the camera\n  pos += vec3(1.5);\n\n  // Combine objects\n  field = 1.0;\n  field = min(field, cube);\n\n  return field;\n}\n\n// Raymarch\n// returns pos ended up at + normal\nvoid rayMarch(inout vec3 pos, vec3 rayDir, out vec3 normal) {\n  float totalDist = 0.0;\n  float dist = EPSILON;\n  for (int i = 0; i < MAX_ITER; i++)\n  {\n    dist = distfunc(pos);\n    totalDist += dist;\n    pos += dist * rayDir;\n\n    if (dist < EPSILON || totalDist > MAX_DIST)\n    break;\n  }\n\n  // Calculate normals\n  if (dist < EPSILON)\n  {\n    vec2 eps = vec2(0.0, EPSILON);\n    normal = normalize(vec3(\n      distfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n      distfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n      distfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n  }\n  else {\n    normal = vec3(0.0);\n  }\n\n}\n\n\n// Main drawing loop\nvoid main(){\n\n  // Camera setup\n  vec3 cameraOrigin = vec3(2.0, 0.0, 0.0);\n  vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n  vec3 upDirection = vec3(0.0, 1.0, 0.0);\n  vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n  vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n  vec3 cameraUp = cross(cameraDir, cameraRight);\n  vec2 screenPos = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy; // screenPos can range from -1 to 1\n  screenPos.x *= resolution.x / resolution.y;                   // Correct aspect ratio\n  vec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\n  // Call raymarch from camera origin\n  vec3 pos = cameraOrigin;\n  vec3 normal;\n  vec3 color = vec3(0.0); // default color\n  //vec3 color = vec3(0.153, 0.157, 0.133); // dark warm grey\n\n  // Iterate\n  for (int i = 0; i < MAX_RECURSE; i++) {\n    rayMarch(pos, rayDir, normal);\n\n    float diffuse, specular;\n\n    // Lighting, from camera\n    diffuse = max(0.0, dot(-rayDir, normal));\n    specular = pow(diffuse, 32.0);\n    color += vec3(diffuse + specular - float(i) +0.3);\n\n\n    // Change direction for re-march.\n    pos -= rayDir*0.1;\n    // Remember to step out a bit, to not hit the object we bounced off!\n    rayDir = reflect(rayDir, normal);\n  }\n\n  // Bias the color a bit\n  color = 0.1+color*0.7;\n\n  //color = vec3(cos(time),sin(time*0.3),sin(time*0.7));\n\n  // vignette\n  vec2 uv = gl_FragCoord.xy / resolution.xy-vec2(.5);\n\n  vec4 src = vec4(1.0,1.0,1.0,1.0);\n  gl_FragColor = vec4(color * exp(-4.0*(uv.x*uv.x+uv.y*uv.y)), 1.0);\n\n  //gl_FragColor = vec4(color, 1.0);\n}\n"}]);